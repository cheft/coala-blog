{
  "blogs": [
    {
      "title": "大公司里怎样开发和部署前端代码？",
      "content": "\n> 本文搬运自我在 [知乎同名问题](http://www.zhihu.com/question/20790576/answer/32602154) 中的答案。\n\n这是一个非常有趣的 ``非主流前端领域``，这个领域要探索的是如何用工程手段解决前端开发和部署优化的综合问题，入行到现在一直在学习和实践中。\n\n在我的印象中，facebook是这个领域的鼻祖，有兴趣、有梯子的同学可以去看看facebook的页面源代码，体会一下什么叫工程化。\n\n接下来，我想从原理展开讲述，多图，较长，希望能有耐心看完。\n\n----------\n\n![一个简单的页面](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/01.png)\n\n让我们返璞归真，从原始的前端开发讲起。上图是一个“可爱”的index.html页面和它的样式文件a.css，用文本编辑器写代码，无需编译，本地预览，确认OK，丢到服务器，等待用户访问。前端就是这么简单，好好玩啊，门槛好低啊，分分钟学会有木有！\n\n![简单页面的网络请求图](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/02.png)\n\n然后我们访问页面，看到效果，再查看一下网络请求，200！不错，太™完美了！那么，研发完成。。。。了么？\n\n等等，这还没完呢！对于大公司来说，那些变态的访问量和性能指标，将会让前端一点也不“好玩”。\n\n看看那个a.css的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊，我们希望最好这样：\n\n![使用304缓存的网络请求图](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/03.png)\n\n利用304，让浏览器使用本地缓存。但，这样也就够了吗？不成！304叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：\n\n![使用本地缓存的网络请求图](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/04.png)\n\n强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？\n\n很好，相信有人想到了办法：**通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源**。好像这样：\n\n![使用构建版本号query更新资源](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/05.png)\n\n下次上线，把链接地址改成新的版本，就更新资源了不是。OK，问题解决了么？！当然没有！大公司的变态又来了，思考这种情况：\n\n![使用构建版本号时上线部署](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/07.png)\n\n页面引用了3个css，而某次上线只改了其中的a.css，如果所有链接都更新版本，就会导致b.css，c.css的缓存也失效，那岂不是又有浪费了？！\n\n重新开启变态模式，我们不难发现，要解决这种问题，必须让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。\n\n什么东西与文件内容相关呢？我们会很自然的联想到利用 [数据摘要要算法](http://baike.baidu.com/view/10961371.htm) 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把url改成带摘要信息的：\n\n![使用摘要信息更新缓存](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/08.png)\n\n这回再有文件修改，就只更新那个文件对应的url了，想到这里貌似很完美了。你觉得这就够了么？大公司告诉你：图样图森破！\n\n唉~~~~，让我喘口气\n\n现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径：\n\n![静态资源分集群部署](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/09.png)\n\n好了，当我要更新静态资源的时候，同时也会更新html中的引用吧，就好像这样：\n\n![CDN部署过程](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/10.png)\n\n这次发布，同时改了页面结构和样式，也更新了静态资源对应的url地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？\n\n1. ``先部署页面，再部署资源``：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。\n1. ``先部署资源，再部署页面``：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。\n好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。\n\n但是，大公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！\n\n这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。\n\n![非覆盖式发布](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/11.png)\n\n看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。\n\n所以，大公司的静态资源优化方案，基本上要实现这么几个东西：\n\n> 1. 配置超长时间的本地缓存 —— 节省带宽，提高性能\n> 2. 采用内容摘要作为缓存更新依据 —— 精确的缓存控制\n> 3. 静态资源CDN部署 —— 优化网络请求\n> 4. 更资源发布路径实现非覆盖式发布 —— 平滑升级\n\n全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在 **前端所有静态资源加载的位置都要做这样的处理** 。是的，所有！什么js、css自不必说，还要包括js、css文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概示意图就是：\n\n![多级依赖示意图](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/14.png)\n\n好了，目前我们快速的学习了一下前端工程中关于静态资源缓存要面临的优化和部署问题，新的问题又来了：这™让工程师怎么写码啊！！！\n\n要解释优化与工程的结合处理思路，又会扯出一堆有关模块化开发、资源加载、请求合并、前端框架等等的工程问题，以上只是开了个头，解决方案才是精髓，但要说的太多太多，有空再慢慢展开吧。\n\n> 总之，前端性能优化绝逼是一个工程问题！\n\n以上不是我YY的，可以观察 百度 或者 facebook 的页面以及静态资源源代码，查看它们的资源引用路径处理，以及网络请中静态资源的缓存控制部分。再次赞叹facebook的前端工程建设水平，跪舔了。\n\n建议前端工程师多多关注前端工程领域，也许有人会觉得自己的产品很小，不用这么变态，但很有可能说不定某天你就需要做出这样的改变了。而且，如果我们能把事情做得更极致，为什么不去做呢？\n\n另外，也不要觉得这些是运维或者后端工程师要解决的问题。如果由其他角色来解决，**大家总是把自己不关心的问题丢给别人**，那么前端工程师的开发过程将受到极大的限制，这种情况甚至在某些大公司都不少见！\n\n妈妈，我再也不玩前端了。。。。5555\n\n## 业界实践\n\n### Assets Pipeline\n\nRails中的Assets Pipeline完成了以上所说的优化细节，对整个静态资源的管理上的设计思考也是如此，了解rails的人也可以把此答案当做是对rails中assets pipeline设计原理的分析。\n\nrails通过把静态资源变成erb模板文件，然后加入<%= asset_path 'image.png' %>，上线前预编译完成处理，fis的实现思路跟这个几乎完全一样，但我们当初确实不知道有rails的这套方案存在。\n\n相关资料：\n\n* 英文版：http://guides.rubyonrails.org/asset_pipeline.html\n* 中文版：http://guides.ruby-china.org/asset_pipeline.html\n\n### FIS的解决方案\n\n用 F.I.S 包装了一个小工具，完整实现整个回答所说的最佳部署方案，并提供了源码对照，可以感受一下项目源码和部署代码的对照。\n\n* 源码项目：[fouber/static-resource-digest-project · GitHub](https://github.com/fouber/static-resource-digest-project)\n* 部署项目：[fouber/static-resource-digest-project-release · GitHub](https://github.com/fouber/static-resource-digest-project-release)\n\n部署项目可以理解为线上发布后的结果，可以在部署项目里查看所有资源引用的md5化处理。\n\n这个示例也可以用于和assets pipeline做比较。fis没有assets的目录规范约束，而且可以以独立工具的方式组合各种前端开发语言（coffee、less、sass/scss、stylus、markdown、jade、ejs、handlebars等等你能想到的），并与其他后端开发语言结合。\n\nassets pipeline的设计思想值得独立成工具用于前端工程，fis就当做这样的一个选择吧。",
      "contentHTML": "<blockquote>\n<p>本文搬运自我在 <a href=\"http://www.zhihu.com/question/20790576/answer/32602154\">知乎同名问题</a> 中的答案。</p>\n</blockquote>\n<p>这是一个非常有趣的 <code>非主流前端领域</code>，这个领域要探索的是如何用工程手段解决前端开发和部署优化的综合问题，入行到现在一直在学习和实践中。</p>\n<p>在我的印象中，facebook是这个领域的鼻祖，有兴趣、有梯子的同学可以去看看facebook的页面源代码，体会一下什么叫工程化。</p>\n<p>接下来，我想从原理展开讲述，多图，较长，希望能有耐心看完。</p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/01.png\" alt=\"一个简单的页面\"></p>\n<p>让我们返璞归真，从原始的前端开发讲起。上图是一个“可爱”的index.html页面和它的样式文件a.css，用文本编辑器写代码，无需编译，本地预览，确认OK，丢到服务器，等待用户访问。前端就是这么简单，好好玩啊，门槛好低啊，分分钟学会有木有！</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/02.png\" alt=\"简单页面的网络请求图\"></p>\n<p>然后我们访问页面，看到效果，再查看一下网络请求，200！不错，太™完美了！那么，研发完成。。。。了么？</p>\n<p>等等，这还没完呢！对于大公司来说，那些变态的访问量和性能指标，将会让前端一点也不“好玩”。</p>\n<p>看看那个a.css的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊，我们希望最好这样：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/03.png\" alt=\"使用304缓存的网络请求图\"></p>\n<p>利用304，让浏览器使用本地缓存。但，这样也就够了吗？不成！304叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/04.png\" alt=\"使用本地缓存的网络请求图\"></p>\n<p>强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？</p>\n<p>很好，相信有人想到了办法：<strong>通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源</strong>。好像这样：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/05.png\" alt=\"使用构建版本号query更新资源\"></p>\n<p>下次上线，把链接地址改成新的版本，就更新资源了不是。OK，问题解决了么？！当然没有！大公司的变态又来了，思考这种情况：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/07.png\" alt=\"使用构建版本号时上线部署\"></p>\n<p>页面引用了3个css，而某次上线只改了其中的a.css，如果所有链接都更新版本，就会导致b.css，c.css的缓存也失效，那岂不是又有浪费了？！</p>\n<p>重新开启变态模式，我们不难发现，要解决这种问题，必须让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。</p>\n<p>什么东西与文件内容相关呢？我们会很自然的联想到利用 <a href=\"http://baike.baidu.com/view/10961371.htm\">数据摘要要算法</a> 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把url改成带摘要信息的：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/08.png\" alt=\"使用摘要信息更新缓存\"></p>\n<p>这回再有文件修改，就只更新那个文件对应的url了，想到这里貌似很完美了。你觉得这就够了么？大公司告诉你：图样图森破！</p>\n<p>唉~~~~，让我喘口气</p>\n<p>现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/09.png\" alt=\"静态资源分集群部署\"></p>\n<p>好了，当我要更新静态资源的时候，同时也会更新html中的引用吧，就好像这样：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/10.png\" alt=\"CDN部署过程\"></p>\n<p>这次发布，同时改了页面结构和样式，也更新了静态资源对应的url地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？</p>\n<ol>\n<li><code>先部署页面，再部署资源</code>：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。</li>\n<li><code>先部署资源，再部署页面</code>：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。<br>好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。</li>\n</ol>\n<p>但是，大公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！</p>\n<p>这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/11.png\" alt=\"非覆盖式发布\"></p>\n<p>看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。</p>\n<p>所以，大公司的静态资源优化方案，基本上要实现这么几个东西：</p>\n<blockquote>\n<ol>\n<li>配置超长时间的本地缓存 —— 节省带宽，提高性能</li>\n<li>采用内容摘要作为缓存更新依据 —— 精确的缓存控制</li>\n<li>静态资源CDN部署 —— 优化网络请求</li>\n<li>更资源发布路径实现非覆盖式发布 —— 平滑升级</li>\n</ol>\n</blockquote>\n<p>全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在 <strong>前端所有静态资源加载的位置都要做这样的处理</strong> 。是的，所有！什么js、css自不必说，还要包括js、css文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概示意图就是：</p>\n<p><img src=\"https://raw.githubusercontent.com/fouber/blog/master/assets/resource/14.png\" alt=\"多级依赖示意图\"></p>\n<p>好了，目前我们快速的学习了一下前端工程中关于静态资源缓存要面临的优化和部署问题，新的问题又来了：这™让工程师怎么写码啊！！！</p>\n<p>要解释优化与工程的结合处理思路，又会扯出一堆有关模块化开发、资源加载、请求合并、前端框架等等的工程问题，以上只是开了个头，解决方案才是精髓，但要说的太多太多，有空再慢慢展开吧。</p>\n<blockquote>\n<p>总之，前端性能优化绝逼是一个工程问题！</p>\n</blockquote>\n<p>以上不是我YY的，可以观察 百度 或者 facebook 的页面以及静态资源源代码，查看它们的资源引用路径处理，以及网络请中静态资源的缓存控制部分。再次赞叹facebook的前端工程建设水平，跪舔了。</p>\n<p>建议前端工程师多多关注前端工程领域，也许有人会觉得自己的产品很小，不用这么变态，但很有可能说不定某天你就需要做出这样的改变了。而且，如果我们能把事情做得更极致，为什么不去做呢？</p>\n<p>另外，也不要觉得这些是运维或者后端工程师要解决的问题。如果由其他角色来解决，<strong>大家总是把自己不关心的问题丢给别人</strong>，那么前端工程师的开发过程将受到极大的限制，这种情况甚至在某些大公司都不少见！</p>\n<p>妈妈，我再也不玩前端了。。。。5555</p>\n<h2 id=\"-\">业界实践</h2>\n<h3 id=\"assets-pipeline\">Assets Pipeline</h3>\n<p>Rails中的Assets Pipeline完成了以上所说的优化细节，对整个静态资源的管理上的设计思考也是如此，了解rails的人也可以把此答案当做是对rails中assets pipeline设计原理的分析。</p>\n<p>rails通过把静态资源变成erb模板文件，然后加入&lt;%= asset_path &#39;image.png&#39; %&gt;，上线前预编译完成处理，fis的实现思路跟这个几乎完全一样，但我们当初确实不知道有rails的这套方案存在。</p>\n<p>相关资料：</p>\n<ul>\n<li>英文版：<a href=\"http://guides.rubyonrails.org/asset_pipeline.html\">http://guides.rubyonrails.org/asset_pipeline.html</a></li>\n<li>中文版：<a href=\"http://guides.ruby-china.org/asset_pipeline.html\">http://guides.ruby-china.org/asset_pipeline.html</a></li>\n</ul>\n<h3 id=\"fis-\">FIS的解决方案</h3>\n<p>用 F.I.S 包装了一个小工具，完整实现整个回答所说的最佳部署方案，并提供了源码对照，可以感受一下项目源码和部署代码的对照。</p>\n<ul>\n<li>源码项目：<a href=\"https://github.com/fouber/static-resource-digest-project\">fouber/static-resource-digest-project · GitHub</a></li>\n<li>部署项目：<a href=\"https://github.com/fouber/static-resource-digest-project-release\">fouber/static-resource-digest-project-release · GitHub</a></li>\n</ul>\n<p>部署项目可以理解为线上发布后的结果，可以在部署项目里查看所有资源引用的md5化处理。</p>\n<p>这个示例也可以用于和assets pipeline做比较。fis没有assets的目录规范约束，而且可以以独立工具的方式组合各种前端开发语言（coffee、less、sass/scss、stylus、markdown、jade、ejs、handlebars等等你能想到的），并与其他后端开发语言结合。</p>\n<p>assets pipeline的设计思想值得独立成工具用于前端工程，fis就当做这样的一个选择吧。</p>\n",
      "createTime": "Wed Apr 05 2017 18:05:42 GMT+0800 (CST)",
      "id": 1
    },
    {
      "title": "前端工程——基础篇",
      "content": "> 喂喂喂，那个切图的，把页面写好就发给研发工程师套模板吧。\n\n你好，切图仔。\n\n不知道你的团队如何定义前端开发，据我所知，时至今日仍然有很多团队会把前端开发归类为产品或者设计岗位，虽然身份之争多少有些无谓，但我对这种偏见还是心存芥蒂，酝酿了许久，决定写一个系列的文章，试着从工程的角度系统的介绍一下我对前端，尤其是Web前端的理解。\n\n只要我们还把自己的工作看作为一项软件开发活动，那么我相信读过下面的内容你也一定会有所共鸣。\n\n## 前端，是一种GUI软件\n\n现如今前端可谓包罗万象，产品形态五花八门，涉猎极广，什么高大上的基础库/框架，拽炫酷的宣传页面，还有屌炸天的小游戏……不过这些一两个文件的小项目并非是前端技术的主要应用场景，更具商业价值的则是复杂的Web应用，它们功能完善，界面繁多，为用户提供了完整的产品体验，可能是新闻聚合网站，可能是在线购物平台，可能是社交网络，可能是金融信贷应用，可能是音乐互动社区，也可能是视频上传与分享平台……\n\n> 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。\n\n如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件：\n\n![](assets/web_gui.png)\n\n尽管Web应用的复杂程度与日俱增，用户对其前端界面也提出了更高的要求，但时至今日仍然没有多少前端开发者会从软件工程的角度去思考前端开发，来助力团队的开发效率，更有甚者还对前端保留着”如玩具般简单“的刻板印象，日复一日，刀耕火种。\n\n历史悠久的前端开发，始终像是放养的野孩子，原始如斯，不免让人慨叹！\n\n## 前端工程的三个阶段\n\n现在的前端开发倒也并非一无所有，回顾一下曾经经历过或听闻过的项目，为了提升其前端开发效率和运行性能，前端团队的工程建设大致会经历三个阶段：\n\n### 第一阶段：库/框架选型\n\n![](assets/libs.png)\n\n前端工程建设的第一项任务就是根据项目特征进行技术选型。\n\n基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。\n\n### 第二阶段：简单构建优化\n\n![](assets/tools.png?v=2)\n\n选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。\n\n前端开发工程化程度之低，常常出乎我的意料，我之前在百度工作时是没有多少概念的，直到离开大公司的温室，去到业界与更多的团队交流才发现，能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看网上形形色色的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。\n\n### 第三阶段：JS/CSS模块化开发\n\n![](assets/libs-2.png?v=2)\n\n分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。\n\n> 很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，是分治，分治！（重说三）。\n> \n> 不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。\n\nJS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。\n\n虽然这些技术由来已久，在如今这个“言必及React”的时代略显落伍，但想想业界的绝大多数团队的工程化落后程度，放眼望去，毫不夸张的说，能达到第三阶段的前端团队已属于高端行列，基本具备了开发维护一般规模Web应用的能力。\n\n然而，做到这些就够了么？Naive！\n\n## 第四阶段\n\n> 前端是一种技术问题较少、工程问题较多的软件开发领域。\n\n当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如：\n\n* 大体量：多功能、多页面、多状态、多系统；\n* 大规模：多人甚至多团队合作开发；\n* 高性能：CDN部署、[缓存控制](https://developers.google.com/speed/docs/insights/LeverageBrowserCaching)、[文件指纹](https://developers.google.com/speed/docs/insights/LeverageBrowserCaching)、缓存复用、请求合并、按需加载、同步/异步加载、移动端[首屏CSS内嵌](https://developers.google.com/speed/docs/insights/mobile)、HTTP 2.0服务端[资源推送](http://chimera.labs.oreilly.com/books/1230000000545/ch12.html#HTTP2_PUSH)。\n\n> 扩展阅读：[大公司里怎样开发和部署前端代码？](https://github.com/fouber/blog/issues/6)\n\n这些无疑是一系列严肃的系统工程问题。\n\n前面讲的三个阶段虽然相比曾经“茹毛饮血”的时代进步不少，但用于支撑第四阶段的多人合作开发以及精细的性能优化似乎还欠缺点什么。\n\n到底，缺什么呢？\n\n## 没有银弹\n\n读过《[人月神话](http://book.douban.com/subject/2230248/)》的人应该都听说过，软件工程 [没有银弹](http://baike.baidu.com/view/277972.htm)。没错，前端开发同样没有银弹，可是现在是连™铅弹都没有的年月！（刚有了BB弹，摔）\n\n前端历来以“简单”著称，在前端开发者群体中，小而美的价值观占据着主要的话语权，甚至成为了某种信仰，想与其他人交流一下工程方面的心得，得到的回应往往都是两个字：太重。\n\n> 重你妹！你的脑容量只有4K吗？\n\n工程方案其实也可以小而美！只不过它的小而美不是指代码量，而是指“规则”。找到问题的根源，用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！\n\n2011年我有幸参与到 [FIS](http://fis.baidu.com) 项目中，与百度众多大中型项目的前端研发团队共同合作，不断探索实践前端开发的工程化解决方案，13年离开百度去往UC，面对完全不同的产品形态，不同的业务场景，不同的适配终端，甚至不同的网络环境，过往的方法论仍然能够快速落地，为多个团队的不同业务场景量身定制出合理的前端解决方案。\n\n这些经历让我明悟了一个道理：\n\n> 进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。\n\n### 第一件事：组件化开发\n\n分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求：\n\n![](assets/components.png)\n\n如上图，这是我所信仰的前端组件化开发理念，简单解读一下：\n\n1. 页面上的每个 **独立的** 可视/可交互区域视为一个组件；\n2. **每个组件对应一个工程目录**，组件所需的各种资源都在这个目录下**就近维护**；\n3. 由于组件具有独立性，因此组件与组件之间可以 **自由组合**；\n4. 页面只不过是组件的容器，负责组合组件形成功能完整的界面；\n4. 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。\n\n其中第二项描述的就近维护原则，是我觉得最具工程价值的地方，它为前端开发提供了很好的分治策略，每个开发者都将清楚的知道，自己所开发维护的功能单元，其代码必然存在于对应的组件目录中，在那个目录下能找到有关这个功能单元的所有内部逻辑，样式也好，JS也好，页面结构也好，都在那里。\n\n组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件HTML部分根据业务选型的不同，可以是静态的HTML文件，可以是前端模板，也可以是后端模板：\n\n![](assets/templates.png)\n\n> 不同的技术选型决定了不同的组件封装和调用策略。\n\n基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分：\n\n![](assets/split.png)\n\n由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。\n\n结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念：\n\n| 名称 | 说明 | 举例 |\n|-----|-----|-----|\n| JS模块 |独立的算法和数据单元|浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元|\n| CSS模块 |独立的功能性样式单元|栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元|\n| UI组件 |独立的可视/可交互功能单元|页头(header)，页尾(footer)，导航栏(nav)，搜索框(search)|\n| 页面 |前端这种GUI软件的界面状态，是UI组件的容器|首页(index)，列表页(list)，用户管理(user)|\n| 应用 |整个项目或整个站点被称之为应用，由多个页面组成| |\n\n以上5种开发概念以相对较少的规则组成了前端开发的基本工程结构，基于这些理念，我眼中的前端开发就成了这个样子：\n\n|示意图|描述|\n|----|----|\n|![](assets/constructor.png)|整个Web应用由页面组成|\n|![](assets/modular_2.png)|页面由组件组成|\n|![](assets/modular-component.png)|一个组件一个目录，资源就近维护|\n|![](assets/modular_4.png)|组件可组合，<br/>组件的JS可依赖其他JS模块，<br/>CSS可依赖其他CSS单元|\n\n综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构：\n\n![](assets/files-x.png)\n\n如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护，针对这种情况后面我会单开文章详细介绍。\n\n以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。\n\n> 吐槽：我本人非常反对某些前端团队将前端开发划分为“JS开发”和“页面重构”两种岗位，更倾向于组件粒度的开发理念，对GUI软件开发的分工规划应该以功能为单位，而不是开发语言；对开发者的技术要求也应该是掌握完整的端内技术。\n",
      "contentHTML": "<blockquote>\n<p>喂喂喂，那个切图的，把页面写好就发给研发工程师套模板吧。</p>\n</blockquote>\n<p>你好，切图仔。</p>\n<p>不知道你的团队如何定义前端开发，据我所知，时至今日仍然有很多团队会把前端开发归类为产品或者设计岗位，虽然身份之争多少有些无谓，但我对这种偏见还是心存芥蒂，酝酿了许久，决定写一个系列的文章，试着从工程的角度系统的介绍一下我对前端，尤其是Web前端的理解。</p>\n<p>只要我们还把自己的工作看作为一项软件开发活动，那么我相信读过下面的内容你也一定会有所共鸣。</p>\n<h2 id=\"-gui-\">前端，是一种GUI软件</h2>\n<p>现如今前端可谓包罗万象，产品形态五花八门，涉猎极广，什么高大上的基础库/框架，拽炫酷的宣传页面，还有屌炸天的小游戏……不过这些一两个文件的小项目并非是前端技术的主要应用场景，更具商业价值的则是复杂的Web应用，它们功能完善，界面繁多，为用户提供了完整的产品体验，可能是新闻聚合网站，可能是在线购物平台，可能是社交网络，可能是金融信贷应用，可能是音乐互动社区，也可能是视频上传与分享平台……</p>\n<blockquote>\n<p>从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。</p>\n</blockquote>\n<p>如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件：</p>\n<p><img src=\"assets/web_gui.png\" alt=\"\"></p>\n<p>尽管Web应用的复杂程度与日俱增，用户对其前端界面也提出了更高的要求，但时至今日仍然没有多少前端开发者会从软件工程的角度去思考前端开发，来助力团队的开发效率，更有甚者还对前端保留着”如玩具般简单“的刻板印象，日复一日，刀耕火种。</p>\n<p>历史悠久的前端开发，始终像是放养的野孩子，原始如斯，不免让人慨叹！</p>\n<h2 id=\"-\">前端工程的三个阶段</h2>\n<p>现在的前端开发倒也并非一无所有，回顾一下曾经经历过或听闻过的项目，为了提升其前端开发效率和运行性能，前端团队的工程建设大致会经历三个阶段：</p>\n<h3 id=\"-\">第一阶段：库/框架选型</h3>\n<p><img src=\"assets/libs.png\" alt=\"\"></p>\n<p>前端工程建设的第一项任务就是根据项目特征进行技术选型。</p>\n<p>基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。</p>\n<h3 id=\"-\">第二阶段：简单构建优化</h3>\n<p><img src=\"assets/tools.png?v=2\" alt=\"\"></p>\n<p>选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。</p>\n<p>前端开发工程化程度之低，常常出乎我的意料，我之前在百度工作时是没有多少概念的，直到离开大公司的温室，去到业界与更多的团队交流才发现，能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看网上形形色色的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。</p>\n<h3 id=\"-js-css-\">第三阶段：JS/CSS模块化开发</h3>\n<p><img src=\"assets/libs-2.png?v=2\" alt=\"\"></p>\n<p>分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。</p>\n<blockquote>\n<p>很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，是分治，分治！（重说三）。</p>\n<p>不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。</p>\n</blockquote>\n<p>JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。</p>\n<p>虽然这些技术由来已久，在如今这个“言必及React”的时代略显落伍，但想想业界的绝大多数团队的工程化落后程度，放眼望去，毫不夸张的说，能达到第三阶段的前端团队已属于高端行列，基本具备了开发维护一般规模Web应用的能力。</p>\n<p>然而，做到这些就够了么？Naive！</p>\n<h2 id=\"-\">第四阶段</h2>\n<blockquote>\n<p>前端是一种技术问题较少、工程问题较多的软件开发领域。</p>\n</blockquote>\n<p>当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如：</p>\n<ul>\n<li>大体量：多功能、多页面、多状态、多系统；</li>\n<li>大规模：多人甚至多团队合作开发；</li>\n<li>高性能：CDN部署、<a href=\"https://developers.google.com/speed/docs/insights/LeverageBrowserCaching\">缓存控制</a>、<a href=\"https://developers.google.com/speed/docs/insights/LeverageBrowserCaching\">文件指纹</a>、缓存复用、请求合并、按需加载、同步/异步加载、移动端<a href=\"https://developers.google.com/speed/docs/insights/mobile\">首屏CSS内嵌</a>、HTTP 2.0服务端<a href=\"http://chimera.labs.oreilly.com/books/1230000000545/ch12.html#HTTP2_PUSH\">资源推送</a>。</li>\n</ul>\n<blockquote>\n<p>扩展阅读：<a href=\"https://github.com/fouber/blog/issues/6\">大公司里怎样开发和部署前端代码？</a></p>\n</blockquote>\n<p>这些无疑是一系列严肃的系统工程问题。</p>\n<p>前面讲的三个阶段虽然相比曾经“茹毛饮血”的时代进步不少，但用于支撑第四阶段的多人合作开发以及精细的性能优化似乎还欠缺点什么。</p>\n<p>到底，缺什么呢？</p>\n<h2 id=\"-\">没有银弹</h2>\n<p>读过《<a href=\"http://book.douban.com/subject/2230248/\">人月神话</a>》的人应该都听说过，软件工程 <a href=\"http://baike.baidu.com/view/277972.htm\">没有银弹</a>。没错，前端开发同样没有银弹，可是现在是连™铅弹都没有的年月！（刚有了BB弹，摔）</p>\n<p>前端历来以“简单”著称，在前端开发者群体中，小而美的价值观占据着主要的话语权，甚至成为了某种信仰，想与其他人交流一下工程方面的心得，得到的回应往往都是两个字：太重。</p>\n<blockquote>\n<p>重你妹！你的脑容量只有4K吗？</p>\n</blockquote>\n<p>工程方案其实也可以小而美！只不过它的小而美不是指代码量，而是指“规则”。找到问题的根源，用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！</p>\n<p>2011年我有幸参与到 <a href=\"http://fis.baidu.com\">FIS</a> 项目中，与百度众多大中型项目的前端研发团队共同合作，不断探索实践前端开发的工程化解决方案，13年离开百度去往UC，面对完全不同的产品形态，不同的业务场景，不同的适配终端，甚至不同的网络环境，过往的方法论仍然能够快速落地，为多个团队的不同业务场景量身定制出合理的前端解决方案。</p>\n<p>这些经历让我明悟了一个道理：</p>\n<blockquote>\n<p>进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。</p>\n</blockquote>\n<h3 id=\"-\">第一件事：组件化开发</h3>\n<p>分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求：</p>\n<p><img src=\"assets/components.png\" alt=\"\"></p>\n<p>如上图，这是我所信仰的前端组件化开发理念，简单解读一下：</p>\n<ol>\n<li>页面上的每个 <strong>独立的</strong> 可视/可交互区域视为一个组件；</li>\n<li><strong>每个组件对应一个工程目录</strong>，组件所需的各种资源都在这个目录下<strong>就近维护</strong>；</li>\n<li>由于组件具有独立性，因此组件与组件之间可以 <strong>自由组合</strong>；</li>\n<li>页面只不过是组件的容器，负责组合组件形成功能完整的界面；</li>\n<li>当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。</li>\n</ol>\n<p>其中第二项描述的就近维护原则，是我觉得最具工程价值的地方，它为前端开发提供了很好的分治策略，每个开发者都将清楚的知道，自己所开发维护的功能单元，其代码必然存在于对应的组件目录中，在那个目录下能找到有关这个功能单元的所有内部逻辑，样式也好，JS也好，页面结构也好，都在那里。</p>\n<p>组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件HTML部分根据业务选型的不同，可以是静态的HTML文件，可以是前端模板，也可以是后端模板：</p>\n<p><img src=\"assets/templates.png\" alt=\"\"></p>\n<blockquote>\n<p>不同的技术选型决定了不同的组件封装和调用策略。</p>\n</blockquote>\n<p>基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分：</p>\n<p><img src=\"assets/split.png\" alt=\"\"></p>\n<p>由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。</p>\n<p>结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JS模块</td>\n<td>独立的算法和数据单元</td>\n<td>浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元</td>\n</tr>\n<tr>\n<td>CSS模块</td>\n<td>独立的功能性样式单元</td>\n<td>栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元</td>\n</tr>\n<tr>\n<td>UI组件</td>\n<td>独立的可视/可交互功能单元</td>\n<td>页头(header)，页尾(footer)，导航栏(nav)，搜索框(search)</td>\n</tr>\n<tr>\n<td>页面</td>\n<td>前端这种GUI软件的界面状态，是UI组件的容器</td>\n<td>首页(index)，列表页(list)，用户管理(user)</td>\n</tr>\n<tr>\n<td>应用</td>\n<td>整个项目或整个站点被称之为应用，由多个页面组成</td>\n</tr>\n</tbody>\n</table>\n<p>以上5种开发概念以相对较少的规则组成了前端开发的基本工程结构，基于这些理念，我眼中的前端开发就成了这个样子：</p>\n<table>\n<thead>\n<tr>\n<th>示意图</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"assets/constructor.png\" alt=\"\"></td>\n<td>整个Web应用由页面组成</td>\n</tr>\n<tr>\n<td><img src=\"assets/modular_2.png\" alt=\"\"></td>\n<td>页面由组件组成</td>\n</tr>\n<tr>\n<td><img src=\"assets/modular-component.png\" alt=\"\"></td>\n<td>一个组件一个目录，资源就近维护</td>\n</tr>\n<tr>\n<td><img src=\"assets/modular_4.png\" alt=\"\"></td>\n<td>组件可组合，<br/>组件的JS可依赖其他JS模块，<br/>CSS可依赖其他CSS单元</td>\n</tr>\n</tbody>\n</table>\n<p>综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构：</p>\n<p><img src=\"assets/files-x.png\" alt=\"\"></p>\n<p>如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护，针对这种情况后面我会单开文章详细介绍。</p>\n<p>以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。</p>\n<blockquote>\n<p>吐槽：我本人非常反对某些前端团队将前端开发划分为“JS开发”和“页面重构”两种岗位，更倾向于组件粒度的开发理念，对GUI软件开发的分工规划应该以功能为单位，而不是开发语言；对开发者的技术要求也应该是掌握完整的端内技术。</p>\n</blockquote>\n",
      "createTime": "Wed Apr 05 2017 18:10:51 GMT+0800 (CST)",
      "id": 2
    }
  ]
}